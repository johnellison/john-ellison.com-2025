"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/contact/page",{

/***/ "(app-pages-browser)/./components/gsap/RainbowGrid.tsx":
/*!*****************************************!*\
  !*** ./components/gsap/RainbowGrid.tsx ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RainbowGrid: () => (/* binding */ RainbowGrid)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ RainbowGrid auto */ \nvar _s = $RefreshSig$();\n\nfunction RainbowGrid({ className = '' }) {\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"RainbowGrid.useEffect\": ()=>{\n            if (!canvasRef.current) return;\n            const canvas = canvasRef.current;\n            const ctx = canvas.getContext('2d');\n            if (!ctx) return;\n            let width, height;\n            let scrollProgress = 0;\n            let targetScrollProgress = 0;\n            let animationId = null;\n            const gridSize = 60;\n            const colors = [\n                {\n                    r: 255,\n                    g: 140,\n                    b: 160\n                },\n                {\n                    r: 255,\n                    g: 180,\n                    b: 120\n                },\n                {\n                    r: 255,\n                    g: 220,\n                    b: 140\n                },\n                {\n                    r: 160,\n                    g: 255,\n                    b: 180\n                },\n                {\n                    r: 140,\n                    g: 200,\n                    b: 255\n                },\n                {\n                    r: 180,\n                    g: 160,\n                    b: 255\n                },\n                {\n                    r: 255,\n                    g: 160,\n                    b: 200\n                }\n            ];\n            function resize() {\n                const dpr = Math.min(window.devicePixelRatio || 1, 2);\n                width = window.innerWidth;\n                height = window.innerHeight;\n                canvas.width = width * dpr;\n                canvas.height = height * dpr;\n                canvas.style.width = width + 'px';\n                canvas.style.height = height + 'px';\n                if (!ctx) return;\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\n                ctx.scale(dpr, dpr);\n            }\n            function getColorAtPosition(x, y, time) {\n                const waveX = Math.sin(x * 0.008 + time * 2) * 0.5 + 0.5;\n                const waveY = Math.sin(y * 0.006 + time * 1.5 + 1) * 0.5 + 0.5;\n                const wave = (waveX + waveY) * 0.5;\n                const colorIndex = (wave * colors.length + time * 3) % colors.length;\n                const colorA = colors[Math.floor(colorIndex) % colors.length];\n                const colorB = colors[Math.ceil(colorIndex) % colors.length];\n                const t = colorIndex % 1;\n                return {\n                    r: colorA.r + (colorB.r - colorA.r) * t,\n                    g: colorA.g + (colorB.g - colorA.g) * t,\n                    b: colorA.b + (colorB.b - colorA.b) * t\n                };\n            }\n            function getIntensityAtPosition(x, y, time) {\n                const pulse1 = Math.sin(x * 0.01 + time * 3) * 0.5 + 0.5;\n                const pulse2 = Math.sin(y * 0.012 - time * 2) * 0.5 + 0.5;\n                const pulse3 = Math.sin((x + y) * 0.005 + time * 1.5) * 0.5 + 0.5;\n                const cx = width / 2;\n                const cy = height / 2;\n                const dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);\n                const maxDist = Math.sqrt(cx ** 2 + cy ** 2);\n                const radialFade = 1 - Math.pow(dist / maxDist, 1.5);\n                return (pulse1 * 0.3 + pulse2 * 0.3 + pulse3 * 0.4) * radialFade;\n            }\n            function draw() {\n                if (!ctx) return;\n                scrollProgress += (targetScrollProgress - scrollProgress) * 0.05;\n                ctx.clearRect(0, 0, width, height);\n                const time = Number.isFinite(scrollProgress) ? scrollProgress : 0;\n                for(let x = 0; x <= width; x += gridSize){\n                    for(let y = 0; y < height; y += 4){\n                        const intensity = getIntensityAtPosition(x, y, time);\n                        if (intensity < 0.1) continue;\n                        const color = getColorAtPosition(x, y, time);\n                        const alpha = intensity * 0.12;\n                        ctx.strokeStyle = `rgba(${Math.round(color.r)}, ${Math.round(color.g)}, ${Math.round(color.b)}, ${alpha})`;\n                        ctx.lineWidth = 1;\n                        ctx.beginPath();\n                        ctx.moveTo(x, y);\n                        ctx.lineTo(x, Math.min(y + 4, height));\n                        ctx.stroke();\n                    }\n                }\n                for(let y = 0; y <= height; y += gridSize){\n                    for(let x = 0; x < width; x += 4){\n                        const intensity = getIntensityAtPosition(x, y, time);\n                        if (intensity < 0.1) continue;\n                        const color = getColorAtPosition(x, y, time);\n                        const alpha = intensity * 0.12;\n                        ctx.strokeStyle = `rgba(${Math.round(color.r)}, ${Math.round(color.g)}, ${Math.round(color.b)}, ${alpha})`;\n                        ctx.lineWidth = 1;\n                        ctx.beginPath();\n                        ctx.moveTo(x, y);\n                        ctx.lineTo(Math.min(x + 4, width), y);\n                        ctx.stroke();\n                    }\n                }\n                animationId = requestAnimationFrame(draw);\n            }\n            function handleScroll() {\n                const docHeight = document.documentElement.scrollHeight - window.innerHeight;\n                if (docHeight <= 0) {\n                    targetScrollProgress = 0;\n                    return;\n                }\n                targetScrollProgress = window.scrollY / docHeight;\n            }\n            resize();\n            window.addEventListener('resize', resize);\n            window.addEventListener('scroll', handleScroll, {\n                passive: true\n            });\n            handleScroll();\n            draw();\n            return ({\n                \"RainbowGrid.useEffect\": ()=>{\n                    if (animationId) cancelAnimationFrame(animationId);\n                    window.removeEventListener('resize', resize);\n                    window.removeEventListener('scroll', handleScroll);\n                }\n            })[\"RainbowGrid.useEffect\"];\n        }\n    }[\"RainbowGrid.useEffect\"], []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n        ref: canvasRef,\n        className: `rainbow-grid-canvas fixed inset-0 z-2 pointer-events-none opacity-80 mix-blend-screen ${className}`\n    }, void 0, false, {\n        fileName: \"/Users/iamjohndass/Sites/john-ellison.com/components/gsap/RainbowGrid.tsx\",\n        lineNumber: 148,\n        columnNumber: 5\n    }, this);\n}\n_s(RainbowGrid, \"UJgi7ynoup7eqypjnwyX/s32POg=\");\n_c = RainbowGrid;\nvar _c;\n$RefreshReg$(_c, \"RainbowGrid\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvZ3NhcC9SYWluYm93R3JpZC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBRTBDO0FBTW5DLFNBQVNFLFlBQVksRUFBRUMsWUFBWSxFQUFFLEVBQW9COztJQUM5RCxNQUFNQyxZQUFZSCw2Q0FBTUEsQ0FBb0I7SUFFNUNELGdEQUFTQTtpQ0FBQztZQUNSLElBQUksQ0FBQ0ksVUFBVUMsT0FBTyxFQUFFO1lBRXhCLE1BQU1DLFNBQVNGLFVBQVVDLE9BQU87WUFDaEMsTUFBTUUsTUFBTUQsT0FBT0UsVUFBVSxDQUFDO1lBQzlCLElBQUksQ0FBQ0QsS0FBSztZQUVWLElBQUlFLE9BQWVDO1lBQ25CLElBQUlDLGlCQUFpQjtZQUNyQixJQUFJQyx1QkFBdUI7WUFDM0IsSUFBSUMsY0FBNkI7WUFFakMsTUFBTUMsV0FBVztZQUVqQixNQUFNQyxTQUFTO2dCQUNiO29CQUFFQyxHQUFHO29CQUFLQyxHQUFHO29CQUFLQyxHQUFHO2dCQUFJO2dCQUN6QjtvQkFBRUYsR0FBRztvQkFBS0MsR0FBRztvQkFBS0MsR0FBRztnQkFBSTtnQkFDekI7b0JBQUVGLEdBQUc7b0JBQUtDLEdBQUc7b0JBQUtDLEdBQUc7Z0JBQUk7Z0JBQ3pCO29CQUFFRixHQUFHO29CQUFLQyxHQUFHO29CQUFLQyxHQUFHO2dCQUFJO2dCQUN6QjtvQkFBRUYsR0FBRztvQkFBS0MsR0FBRztvQkFBS0MsR0FBRztnQkFBSTtnQkFDekI7b0JBQUVGLEdBQUc7b0JBQUtDLEdBQUc7b0JBQUtDLEdBQUc7Z0JBQUk7Z0JBQ3pCO29CQUFFRixHQUFHO29CQUFLQyxHQUFHO29CQUFLQyxHQUFHO2dCQUFJO2FBQzFCO1lBRUQsU0FBU0M7Z0JBQ1AsTUFBTUMsTUFBTUMsS0FBS0MsR0FBRyxDQUFDQyxPQUFPQyxnQkFBZ0IsSUFBSSxHQUFHO2dCQUNuRGYsUUFBUWMsT0FBT0UsVUFBVTtnQkFDekJmLFNBQVNhLE9BQU9HLFdBQVc7Z0JBQzNCcEIsT0FBT0cs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QyxDQUFDLEVBQUUsRUFBRSxFQUFFNEMsTUFBTSxDQUFDLENBQUM7d0JBQzFHdkQsSUFBSTBELFNBQVMsR0FBRzt3QkFDaEIxRCxJQUFJMkQsU0FBUzt3QkFDYjNELElBQUk0RCxNQUFNLENBQUNwQyxHQUFHQzt3QkFDZHpCLElBQUk2RCxNQUFNLENBQUMvQyxLQUFLQyxHQUFHLENBQUNTLElBQUksR0FBR3RCLFFBQVF1Qjt3QkFDbkN6QixJQUFJOEQsTUFBTTtvQkFDWjtnQkFDRjtnQkFFQXhELGNBQWN5RCxzQkFBc0JkO1lBQ3RDO1lBRUEsU0FBU2U7Z0JBQ1AsTUFBTUMsWUFBWUMsU0FBU0MsZUFBZSxDQUFDQyxZQUFZLEdBQUdwRCxPQUFPRyxXQUFXO2dCQUM1RSxJQUFJOEMsYUFBYSxHQUFHO29CQUNsQjVELHVCQUF1QjtvQkFDdkI7Z0JBQ0Y7Z0JBQ0FBLHVCQUF1QlcsT0FBT3FELE9BQU8sR0FBR0o7WUFDMUM7WUFFQXJEO1lBQ0FJLE9BQU9zRCxnQkFBZ0IsQ0FBQyxVQUFVMUQ7WUFDbENJLE9BQU9zRCxnQkFBZ0IsQ0FBQyxVQUFVTixjQUFjO2dCQUFFTyxTQUFTO1lBQUs7WUFDaEVQO1lBQ0FmO1lBRUE7eUNBQU87b0JBQ0wsSUFBSTNDLGFBQWFrRSxxQkFBcUJsRTtvQkFDdENVLE9BQU95RCxtQkFBbUIsQ0FBQyxVQUFVN0Q7b0JBQ3JDSSxPQUFPeUQsbUJBQW1CLENBQUMsVUFBVVQ7Z0JBQ3ZDOztRQUNGO2dDQUFHLEVBQUU7SUFFTCxxQkFDRSw4REFBQ2pFO1FBQ0MyRSxLQUFLN0U7UUFDTEQsV0FBVyxDQUFDLHNGQUFzRixFQUFFQSxXQUFXOzs7Ozs7QUFHckg7R0FoSmdCRDtLQUFBQSIsInNvdXJjZXMiOlsiL1VzZXJzL2lhbWpvaG5kYXNzL1NpdGVzL2pvaG4tZWxsaXNvbi5jb20vY29tcG9uZW50cy9nc2FwL1JhaW5ib3dHcmlkLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuXG5pbnRlcmZhY2UgUmFpbmJvd0dyaWRQcm9wcyB7XG4gIGNsYXNzTmFtZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJhaW5ib3dHcmlkKHsgY2xhc3NOYW1lID0gJycgfTogUmFpbmJvd0dyaWRQcm9wcykge1xuICBjb25zdCBjYW52YXNSZWYgPSB1c2VSZWY8SFRNTENhbnZhc0VsZW1lbnQ+KG51bGwpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFjYW52YXNSZWYuY3VycmVudCkgcmV0dXJuO1xuXG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgaWYgKCFjdHgpIHJldHVybjtcblxuICAgIGxldCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcjtcbiAgICBsZXQgc2Nyb2xsUHJvZ3Jlc3MgPSAwO1xuICAgIGxldCB0YXJnZXRTY3JvbGxQcm9ncmVzcyA9IDA7XG4gICAgbGV0IGFuaW1hdGlvbklkOiBudW1iZXIgfCBudWxsID0gbnVsbDtcblxuICAgIGNvbnN0IGdyaWRTaXplID0gNjA7XG5cbiAgICBjb25zdCBjb2xvcnMgPSBbXG4gICAgICB7IHI6IDI1NSwgZzogMTQwLCBiOiAxNjAgfSxcbiAgICAgIHsgcjogMjU1LCBnOiAxODAsIGI6IDEyMCB9LFxuICAgICAgeyByOiAyNTUsIGc6IDIyMCwgYjogMTQwIH0sXG4gICAgICB7IHI6IDE2MCwgZzogMjU1LCBiOiAxODAgfSxcbiAgICAgIHsgcjogMTQwLCBnOiAyMDAsIGI6IDI1NSB9LFxuICAgICAgeyByOiAxODAsIGc6IDE2MCwgYjogMjU1IH0sXG4gICAgICB7IHI6IDI1NSwgZzogMTYwLCBiOiAyMDAgfSxcbiAgICBdO1xuXG4gICAgZnVuY3Rpb24gcmVzaXplKCkge1xuICAgICAgY29uc3QgZHByID0gTWF0aC5taW4od2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSwgMik7XG4gICAgICB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgY2FudmFzLndpZHRoID0gd2lkdGggKiBkcHI7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogZHByO1xuICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgICBpZiAoIWN0eCkgcmV0dXJuO1xuICAgICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIGN0eC5zY2FsZShkcHIsIGRwcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q29sb3JBdFBvc2l0aW9uKHg6IG51bWJlciwgeTogbnVtYmVyLCB0aW1lOiBudW1iZXIpIHtcbiAgICAgIGNvbnN0IHdhdmVYID0gTWF0aC5zaW4oeCAqIDAuMDA4ICsgdGltZSAqIDIpICogMC41ICsgMC41O1xuICAgICAgY29uc3Qgd2F2ZVkgPSBNYXRoLnNpbih5ICogMC4wMDYgKyB0aW1lICogMS41ICsgMSkgKiAwLjUgKyAwLjU7XG4gICAgICBjb25zdCB3YXZlID0gKHdhdmVYICsgd2F2ZVkpICogMC41O1xuXG4gICAgICBjb25zdCBjb2xvckluZGV4ID0gKHdhdmUgKiBjb2xvcnMubGVuZ3RoICsgdGltZSAqIDMpICUgY29sb3JzLmxlbmd0aDtcbiAgICAgIGNvbnN0IGNvbG9yQSA9IGNvbG9yc1tNYXRoLmZsb29yKGNvbG9ySW5kZXgpICUgY29sb3JzLmxlbmd0aF07XG4gICAgICBjb25zdCBjb2xvckIgPSBjb2xvcnNbTWF0aC5jZWlsKGNvbG9ySW5kZXgpICUgY29sb3JzLmxlbmd0aF07XG4gICAgICBjb25zdCB0ID0gY29sb3JJbmRleCAlIDE7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHI6IGNvbG9yQS5yICsgKGNvbG9yQi5yIC0gY29sb3JBLnIpICogdCxcbiAgICAgICAgZzogY29sb3JBLmcgKyAoY29sb3JCLmcgLSBjb2xvckEuZykgKiB0LFxuICAgICAgICBiOiBjb2xvckEuYiArIChjb2xvckIuYiAtIGNvbG9yQS5iKSAqIHQsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEludGVuc2l0eUF0UG9zaXRpb24oeDogbnVtYmVyLCB5OiBudW1iZXIsIHRpbWU6IG51bWJlcikge1xuICAgICAgY29uc3QgcHVsc2UxID0gTWF0aC5zaW4oeCAqIDAuMDEgKyB0aW1lICogMykgKiAwLjUgKyAwLjU7XG4gICAgICBjb25zdCBwdWxzZTIgPSBNYXRoLnNpbih5ICogMC4wMTIgLSB0aW1lICogMikgKiAwLjUgKyAwLjU7XG4gICAgICBjb25zdCBwdWxzZTMgPSBNYXRoLnNpbigoeCArIHkpICogMC4wMDUgKyB0aW1lICogMS41KSAqIDAuNSArIDAuNTtcblxuICAgICAgY29uc3QgY3ggPSB3aWR0aCAvIDI7XG4gICAgICBjb25zdCBjeSA9IGhlaWdodCAvIDI7XG4gICAgICBjb25zdCBkaXN0ID0gTWF0aC5zcXJ0KCh4IC0gY3gpICoqIDIgKyAoeSAtIGN5KSAqKiAyKTtcbiAgICAgIGNvbnN0IG1heERpc3QgPSBNYXRoLnNxcnQoY3ggKiogMiArIGN5ICoqIDIpO1xuICAgICAgY29uc3QgcmFkaWFsRmFkZSA9IDEgLSBNYXRoLnBvdyhkaXN0IC8gbWF4RGlzdCwgMS41KTtcblxuICAgICAgcmV0dXJuIChwdWxzZTEgKiAwLjMgKyBwdWxzZTIgKiAwLjMgKyBwdWxzZTMgKiAwLjQpICogcmFkaWFsRmFkZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkcmF3KCkge1xuICAgICAgaWYgKCFjdHgpIHJldHVybjtcbiAgICAgIHNjcm9sbFByb2dyZXNzICs9ICh0YXJnZXRTY3JvbGxQcm9ncmVzcyAtIHNjcm9sbFByb2dyZXNzKSAqIDAuMDU7XG5cbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgIGNvbnN0IHRpbWUgPSBOdW1iZXIuaXNGaW5pdGUoc2Nyb2xsUHJvZ3Jlc3MpID8gc2Nyb2xsUHJvZ3Jlc3MgOiAwO1xuXG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8PSB3aWR0aDsgeCArPSBncmlkU2l6ZSkge1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSArPSA0KSB7XG4gICAgICAgICAgY29uc3QgaW50ZW5zaXR5ID0gZ2V0SW50ZW5zaXR5QXRQb3NpdGlvbih4LCB5LCB0aW1lKTtcbiAgICAgICAgICBpZiAoaW50ZW5zaXR5IDwgMC4xKSBjb250aW51ZTtcblxuICAgICAgICAgIGNvbnN0IGNvbG9yID0gZ2V0Q29sb3JBdFBvc2l0aW9uKHgsIHksIHRpbWUpO1xuICAgICAgICAgIGNvbnN0IGFscGhhID0gaW50ZW5zaXR5ICogMC4xMjtcblxuICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGByZ2JhKCR7TWF0aC5yb3VuZChjb2xvci5yKX0sICR7TWF0aC5yb3VuZChjb2xvci5nKX0sICR7TWF0aC5yb3VuZChjb2xvci5iKX0sICR7YWxwaGF9KWA7XG4gICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgY3R4LmxpbmVUbyh4LCBNYXRoLm1pbih5ICsgNCwgaGVpZ2h0KSk7XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDw9IGhlaWdodDsgeSArPSBncmlkU2l6ZSkge1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4ICs9IDQpIHtcbiAgICAgICAgICBjb25zdCBpbnRlbnNpdHkgPSBnZXRJbnRlbnNpdHlBdFBvc2l0aW9uKHgsIHksIHRpbWUpO1xuICAgICAgICAgIGlmIChpbnRlbnNpdHkgPCAwLjEpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgY29uc3QgY29sb3IgPSBnZXRDb2xvckF0UG9zaXRpb24oeCwgeSwgdGltZSk7XG4gICAgICAgICAgY29uc3QgYWxwaGEgPSBpbnRlbnNpdHkgKiAwLjEyO1xuXG4gICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gYHJnYmEoJHtNYXRoLnJvdW5kKGNvbG9yLnIpfSwgJHtNYXRoLnJvdW5kKGNvbG9yLmcpfSwgJHtNYXRoLnJvdW5kKGNvbG9yLmIpfSwgJHthbHBoYX0pYDtcbiAgICAgICAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgICAgICBjdHgubGluZVRvKE1hdGgubWluKHggKyA0LCB3aWR0aCksIHkpO1xuICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhbmltYXRpb25JZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShkcmF3KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVTY3JvbGwoKSB7XG4gICAgICBjb25zdCBkb2NIZWlnaHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0IC0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgaWYgKGRvY0hlaWdodCA8PSAwKSB7XG4gICAgICAgIHRhcmdldFNjcm9sbFByb2dyZXNzID0gMDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGFyZ2V0U2Nyb2xsUHJvZ3Jlc3MgPSB3aW5kb3cuc2Nyb2xsWSAvIGRvY0hlaWdodDtcbiAgICB9XG5cbiAgICByZXNpemUoKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlU2Nyb2xsLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgaGFuZGxlU2Nyb2xsKCk7XG4gICAgZHJhdygpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChhbmltYXRpb25JZCkgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uSWQpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHJlc2l6ZSk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlU2Nyb2xsKTtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8Y2FudmFzXG4gICAgICByZWY9e2NhbnZhc1JlZn1cbiAgICAgIGNsYXNzTmFtZT17YHJhaW5ib3ctZ3JpZC1jYW52YXMgZml4ZWQgaW5zZXQtMCB6LTIgcG9pbnRlci1ldmVudHMtbm9uZSBvcGFjaXR5LTgwIG1peC1ibGVuZC1zY3JlZW4gJHtjbGFzc05hbWV9YH1cbiAgICAvPlxuICApO1xufVxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsIlJhaW5ib3dHcmlkIiwiY2xhc3NOYW1lIiwiY2FudmFzUmVmIiwiY3VycmVudCIsImNhbnZhcyIsImN0eCIsImdldENvbnRleHQiLCJ3aWR0aCIsImhlaWdodCIsInNjcm9sbFByb2dyZXNzIiwidGFyZ2V0U2Nyb2xsUHJvZ3Jlc3MiLCJhbmltYXRpb25JZCIsImdyaWRTaXplIiwiY29sb3JzIiwiciIsImciLCJiIiwicmVzaXplIiwiZHByIiwiTWF0aCIsIm1pbiIsIndpbmRvdyIsImRldmljZVBpeGVsUmF0aW8iLCJpbm5lcldpZHRoIiwiaW5uZXJIZWlnaHQiLCJzdHlsZSIsInNldFRyYW5zZm9ybSIsInNjYWxlIiwiZ2V0Q29sb3JBdFBvc2l0aW9uIiwieCIsInkiLCJ0aW1lIiwid2F2ZVgiLCJzaW4iLCJ3YXZlWSIsIndhdmUiLCJjb2xvckluZGV4IiwibGVuZ3RoIiwiY29sb3JBIiwiZmxvb3IiLCJjb2xvckIiLCJjZWlsIiwidCIsImdldEludGVuc2l0eUF0UG9zaXRpb24iLCJwdWxzZTEiLCJwdWxzZTIiLCJwdWxzZTMiLCJjeCIsImN5IiwiZGlzdCIsInNxcnQiLCJtYXhEaXN0IiwicmFkaWFsRmFkZSIsInBvdyIsImRyYXciLCJjbGVhclJlY3QiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImludGVuc2l0eSIsImNvbG9yIiwiYWxwaGEiLCJzdHJva2VTdHlsZSIsInJvdW5kIiwibGluZVdpZHRoIiwiYmVnaW5QYXRoIiwibW92ZVRvIiwibGluZVRvIiwic3Ryb2tlIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiaGFuZGxlU2Nyb2xsIiwiZG9jSGVpZ2h0IiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJzY3JvbGxIZWlnaHQiLCJzY3JvbGxZIiwiYWRkRXZlbnRMaXN0ZW5lciIsInBhc3NpdmUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyZWYiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/gsap/RainbowGrid.tsx\n"));

/***/ })

});
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/contact/page",{

/***/ "(app-pages-browser)/./components/gsap/RainbowGrid.tsx":
/*!*****************************************!*\
  !*** ./components/gsap/RainbowGrid.tsx ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RainbowGrid: () => (/* binding */ RainbowGrid)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ RainbowGrid auto */ \nvar _s = $RefreshSig$();\n\nfunction RainbowGrid({ className = '' }) {\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"RainbowGrid.useEffect\": ()=>{\n            if (!canvasRef.current) return;\n            const canvas = canvasRef.current;\n            const ctx = canvas.getContext('2d');\n            if (!ctx) return;\n            let width, height;\n            let scrollProgress = 0;\n            let targetScrollProgress = 0;\n            let animationId = null;\n            const gridSize = 60;\n            const colors = [\n                {\n                    r: 255,\n                    g: 140,\n                    b: 160\n                },\n                {\n                    r: 255,\n                    g: 180,\n                    b: 120\n                },\n                {\n                    r: 255,\n                    g: 220,\n                    b: 140\n                },\n                {\n                    r: 160,\n                    g: 255,\n                    b: 180\n                },\n                {\n                    r: 140,\n                    g: 200,\n                    b: 255\n                },\n                {\n                    r: 180,\n                    g: 160,\n                    b: 255\n                },\n                {\n                    r: 255,\n                    g: 160,\n                    b: 200\n                }\n            ];\n            function resize() {\n                const dpr = Math.min(window.devicePixelRatio || 1, 2);\n                width = window.innerWidth;\n                height = window.innerHeight;\n                canvas.width = width * dpr;\n                canvas.height = height * dpr;\n                canvas.style.width = width + 'px';\n                canvas.style.height = height + 'px';\n                if (!ctx) return;\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\n                ctx.scale(dpr, dpr);\n            }\n            function getColorAtPosition(x, y, time) {\n                const waveX = Math.sin(x * 0.008 + time * 2) * 0.5 + 0.5;\n                const waveY = Math.sin(y * 0.006 + time * 1.5 + 1) * 0.5 + 0.5;\n                const wave = (waveX + waveY) * 0.5;\n                const colorIndex = (wave * colors.length + time * 3) % colors.length;\n                if (!Number.isFinite(colorIndex)) {\n                    return colors[0];\n                }\n                const colorA = colors[Math.floor(colorIndex) % colors.length];\n                const colorB = colors[Math.ceil(colorIndex) % colors.length];\n                const t = colorIndex % 1;\n                return {\n                    r: colorA.r + (colorB.r - colorA.r) * t,\n                    g: colorA.g + (colorB.g - colorA.g) * t,\n                    b: colorA.b + (colorB.b - colorA.b) * t\n                };\n            }\n            function getIntensityAtPosition(x, y, time) {\n                const pulse1 = Math.sin(x * 0.01 + time * 3) * 0.5 + 0.5;\n                const pulse2 = Math.sin(y * 0.012 - time * 2) * 0.5 + 0.5;\n                const pulse3 = Math.sin((x + y) * 0.005 + time * 1.5) * 0.5 + 0.5;\n                const cx = width / 2;\n                const cy = height / 2;\n                const dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);\n                const maxDist = Math.sqrt(cx ** 2 + cy ** 2);\n                const radialFade = 1 - Math.pow(dist / maxDist, 1.5);\n                return (pulse1 * 0.3 + pulse2 * 0.3 + pulse3 * 0.4) * radialFade;\n            }\n            function draw() {\n                if (!ctx) return;\n                scrollProgress += (targetScrollProgress - scrollProgress) * 0.05;\n                ctx.clearRect(0, 0, width, height);\n                const time = Number.isFinite(scrollProgress) ? scrollProgress : 0;\n                for(let x = 0; x <= width; x += gridSize){\n                    for(let y = 0; y < height; y += 4){\n                        const intensity = getIntensityAtPosition(x, y, time);\n                        if (intensity < 0.1) continue;\n                        const color = getColorAtPosition(x, y, time);\n                        const alpha = intensity * 0.12;\n                        ctx.strokeStyle = `rgba(${Math.round(color.r)}, ${Math.round(color.g)}, ${Math.round(color.b)}, ${alpha})`;\n                        ctx.lineWidth = 1;\n                        ctx.beginPath();\n                        ctx.moveTo(x, y);\n                        ctx.lineTo(x, Math.min(y + 4, height));\n                        ctx.stroke();\n                    }\n                }\n                for(let y = 0; y <= height; y += gridSize){\n                    for(let x = 0; x < width; x += 4){\n                        const intensity = getIntensityAtPosition(x, y, time);\n                        if (intensity < 0.1) continue;\n                        const color = getColorAtPosition(x, y, time);\n                        const alpha = intensity * 0.12;\n                        ctx.strokeStyle = `rgba(${Math.round(color.r)}, ${Math.round(color.g)}, ${Math.round(color.b)}, ${alpha})`;\n                        ctx.lineWidth = 1;\n                        ctx.beginPath();\n                        ctx.moveTo(x, y);\n                        ctx.lineTo(Math.min(x + 4, width), y);\n                        ctx.stroke();\n                    }\n                }\n                animationId = requestAnimationFrame(draw);\n            }\n            function handleScroll() {\n                const docHeight = document.documentElement.scrollHeight - window.innerHeight;\n                if (!Number.isFinite(docHeight) || docHeight <= 0) {\n                    targetScrollProgress = 0;\n                    return;\n                }\n                targetScrollProgress = window.scrollY / docHeight;\n            }\n            resize();\n            window.addEventListener('resize', resize);\n            window.addEventListener('scroll', handleScroll, {\n                passive: true\n            });\n            handleScroll();\n            draw();\n            return ({\n                \"RainbowGrid.useEffect\": ()=>{\n                    if (animationId) cancelAnimationFrame(animationId);\n                    window.removeEventListener('resize', resize);\n                    window.removeEventListener('scroll', handleScroll);\n                }\n            })[\"RainbowGrid.useEffect\"];\n        }\n    }[\"RainbowGrid.useEffect\"], []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n        ref: canvasRef,\n        className: `rainbow-grid-canvas fixed inset-0 z-2 pointer-events-none opacity-80 mix-blend-screen ${className}`\n    }, void 0, false, {\n        fileName: \"/Users/iamjohndass/Sites/john-ellison.com/components/gsap/RainbowGrid.tsx\",\n        lineNumber: 151,\n        columnNumber: 5\n    }, this);\n}\n_s(RainbowGrid, \"UJgi7ynoup7eqypjnwyX/s32POg=\");\n_c = RainbowGrid;\nvar _c;\n$RefreshReg$(_c, \"RainbowGrid\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvZ3NhcC9SYWluYm93R3JpZC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBRTBDO0FBTW5DLFNBQVNFLFlBQVksRUFBRUMsWUFBWSxFQUFFLEVBQW9COztJQUM5RCxNQUFNQyxZQUFZSCw2Q0FBTUEsQ0FBb0I7SUFFNUNELGdEQUFTQTtpQ0FBQztZQUNSLElBQUksQ0FBQ0ksVUFBVUMsT0FBTyxFQUFFO1lBRXhCLE1BQU1DLFNBQVNGLFVBQVVDLE9BQU87WUFDaEMsTUFBTUUsTUFBTUQsT0FBT0UsVUFBVSxDQUFDO1lBQzlCLElBQUksQ0FBQ0QsS0FBSztZQUVWLElBQUlFLE9BQWVDO1lBQ25CLElBQUlDLGlCQUFpQjtZQUNyQixJQUFJQyx1QkFBdUI7WUFDM0IsSUFBSUMsY0FBNkI7WUFFakMsTUFBTUMsV0FBVztZQUVqQixNQUFNQyxTQUFTO2dCQUNiO29CQUFFQyxHQUFHO29CQUFLQyxHQUFHO29CQUFLQyxHQUFHO2dCQUFJO2dCQUN6QjtvQkFBRUYsR0FBRztvQkFBS0MsR0FBRztvQkFBS0MsR0FBRztnQkFBSTtnQkFDekI7b0JBQUVGLEdBQUc7b0JBQUtDLEdBQUc7b0JBQUtDLEdBQUc7Z0JBQUk7Z0JBQ3pCO29CQUFFRixHQUFHO29CQUFLQyxHQUFHO29CQUFLQyxHQUFHO2dCQUFJO2dCQUN6QjtvQkFBRUYsR0FBRztvQkFBS0MsR0FBRztvQkFBS0MsR0FBRztnQkFBSTtnQkFDekI7b0JBQUVGLEdBQUc7b0JBQUtDLEdBQUc7b0JBQUtDLEdBQUc7Z0JBQUk7Z0JBQ3pCO29CQUFFRixHQUFHO29CQUFLQyxHQUFHO29CQUFLQyxHQUFHO2dCQUFJO2FBQzFCO1lBRUQsU0FBU0M7Z0JBQ1AsTUFBTUMsTUFBTUMsS0FBS0MsR0FBRyxDQUFDQyxPQUFPQyxnQkFBZ0IsSUFBSSxHQUFHO2dCQUNuRGYsUUFBUWMsT0FBT0UsVUFBVTtnQkFDekJmLFNBQVNhLE9BQU9HLFdBQVc7Z0JBQzNCcEIsT0FBT0cs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cG9uZW50cy9nc2FwL1JhaW5ib3dHcmlkLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuXG5pbnRlcmZhY2UgUmFpbmJvd0dyaWRQcm9wcyB7XG4gIGNsYXNzTmFtZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJhaW5ib3dHcmlkKHsgY2xhc3NOYW1lID0gJycgfTogUmFpbmJvd0dyaWRQcm9wcykge1xuICBjb25zdCBjYW52YXNSZWYgPSB1c2VSZWY8SFRNTENhbnZhc0VsZW1lbnQ+KG51bGwpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFjYW52YXNSZWYuY3VycmVudCkgcmV0dXJuO1xuXG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgaWYgKCFjdHgpIHJldHVybjtcblxuICAgIGxldCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcjtcbiAgICBsZXQgc2Nyb2xsUHJvZ3Jlc3MgPSAwO1xuICAgIGxldCB0YXJnZXRTY3JvbGxQcm9ncmVzcyA9IDA7XG4gICAgbGV0IGFuaW1hdGlvbklkOiBudW1iZXIgfCBudWxsID0gbnVsbDtcblxuICAgIGNvbnN0IGdyaWRTaXplID0gNjA7XG5cbiAgICBjb25zdCBjb2xvcnMgPSBbXG4gICAgICB7IHI6IDI1NSwgZzogMTQwLCBiOiAxNjAgfSxcbiAgICAgIHsgcjogMjU1LCBnOiAxODAsIGI6IDEyMCB9LFxuICAgICAgeyByOiAyNTUsIGc6IDIyMCwgYjogMTQwIH0sXG4gICAgICB7IHI6IDE2MCwgZzogMjU1LCBiOiAxODAgfSxcbiAgICAgIHsgcjogMTQwLCBnOiAyMDAsIGI6IDI1NSB9LFxuICAgICAgeyByOiAxODAsIGc6IDE2MCwgYjogMjU1IH0sXG4gICAgICB7IHI6IDI1NSwgZzogMTYwLCBiOiAyMDAgfSxcbiAgICBdO1xuXG4gICAgZnVuY3Rpb24gcmVzaXplKCkge1xuICAgICAgY29uc3QgZHByID0gTWF0aC5taW4od2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSwgMik7XG4gICAgICB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgY2FudmFzLndpZHRoID0gd2lkdGggKiBkcHI7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogZHByO1xuICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgICBpZiAoIWN0eCkgcmV0dXJuO1xuICAgICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIGN0eC5zY2FsZShkcHIsIGRwcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q29sb3JBdFBvc2l0aW9uKHg6IG51bWJlciwgeTogbnVtYmVyLCB0aW1lOiBudW1iZXIpIHtcbiAgICAgIGNvbnN0IHdhdmVYID0gTWF0aC5zaW4oeCAqIDAuMDA4ICsgdGltZSAqIDIpICogMC41ICsgMC41O1xuICAgICAgY29uc3Qgd2F2ZVkgPSBNYXRoLnNpbih5ICogMC4wMDYgKyB0aW1lICogMS41ICsgMSkgKiAwLjUgKyAwLjU7XG4gICAgICBjb25zdCB3YXZlID0gKHdhdmVYICsgd2F2ZVkpICogMC41O1xuXG4gICAgICBjb25zdCBjb2xvckluZGV4ID0gKHdhdmUgKiBjb2xvcnMubGVuZ3RoICsgdGltZSAqIDMpICUgY29sb3JzLmxlbmd0aDtcbiAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGNvbG9ySW5kZXgpKSB7XG4gICAgICAgIHJldHVybiBjb2xvcnNbMF07XG4gICAgICB9XG4gICAgICBjb25zdCBjb2xvckEgPSBjb2xvcnNbTWF0aC5mbG9vcihjb2xvckluZGV4KSAlIGNvbG9ycy5sZW5ndGhdO1xuICAgICAgY29uc3QgY29sb3JCID0gY29sb3JzW01hdGguY2VpbChjb2xvckluZGV4KSAlIGNvbG9ycy5sZW5ndGhdO1xuICAgICAgY29uc3QgdCA9IGNvbG9ySW5kZXggJSAxO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICByOiBjb2xvckEuciArIChjb2xvckIuciAtIGNvbG9yQS5yKSAqIHQsXG4gICAgICAgIGc6IGNvbG9yQS5nICsgKGNvbG9yQi5nIC0gY29sb3JBLmcpICogdCxcbiAgICAgICAgYjogY29sb3JBLmIgKyAoY29sb3JCLmIgLSBjb2xvckEuYikgKiB0LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJbnRlbnNpdHlBdFBvc2l0aW9uKHg6IG51bWJlciwgeTogbnVtYmVyLCB0aW1lOiBudW1iZXIpIHtcbiAgICAgIGNvbnN0IHB1bHNlMSA9IE1hdGguc2luKHggKiAwLjAxICsgdGltZSAqIDMpICogMC41ICsgMC41O1xuICAgICAgY29uc3QgcHVsc2UyID0gTWF0aC5zaW4oeSAqIDAuMDEyIC0gdGltZSAqIDIpICogMC41ICsgMC41O1xuICAgICAgY29uc3QgcHVsc2UzID0gTWF0aC5zaW4oKHggKyB5KSAqIDAuMDA1ICsgdGltZSAqIDEuNSkgKiAwLjUgKyAwLjU7XG5cbiAgICAgIGNvbnN0IGN4ID0gd2lkdGggLyAyO1xuICAgICAgY29uc3QgY3kgPSBoZWlnaHQgLyAyO1xuICAgICAgY29uc3QgZGlzdCA9IE1hdGguc3FydCgoeCAtIGN4KSAqKiAyICsgKHkgLSBjeSkgKiogMik7XG4gICAgICBjb25zdCBtYXhEaXN0ID0gTWF0aC5zcXJ0KGN4ICoqIDIgKyBjeSAqKiAyKTtcbiAgICAgIGNvbnN0IHJhZGlhbEZhZGUgPSAxIC0gTWF0aC5wb3coZGlzdCAvIG1heERpc3QsIDEuNSk7XG5cbiAgICAgIHJldHVybiAocHVsc2UxICogMC4zICsgcHVsc2UyICogMC4zICsgcHVsc2UzICogMC40KSAqIHJhZGlhbEZhZGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJhdygpIHtcbiAgICAgIGlmICghY3R4KSByZXR1cm47XG4gICAgICBzY3JvbGxQcm9ncmVzcyArPSAodGFyZ2V0U2Nyb2xsUHJvZ3Jlc3MgLSBzY3JvbGxQcm9ncmVzcykgKiAwLjA1O1xuXG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICBjb25zdCB0aW1lID0gTnVtYmVyLmlzRmluaXRlKHNjcm9sbFByb2dyZXNzKSA/IHNjcm9sbFByb2dyZXNzIDogMDtcblxuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPD0gd2lkdGg7IHggKz0gZ3JpZFNpemUpIHtcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkgKz0gNCkge1xuICAgICAgICAgIGNvbnN0IGludGVuc2l0eSA9IGdldEludGVuc2l0eUF0UG9zaXRpb24oeCwgeSwgdGltZSk7XG4gICAgICAgICAgaWYgKGludGVuc2l0eSA8IDAuMSkgY29udGludWU7XG5cbiAgICAgICAgICBjb25zdCBjb2xvciA9IGdldENvbG9yQXRQb3NpdGlvbih4LCB5LCB0aW1lKTtcbiAgICAgICAgICBjb25zdCBhbHBoYSA9IGludGVuc2l0eSAqIDAuMTI7XG5cbiAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBgcmdiYSgke01hdGgucm91bmQoY29sb3Iucil9LCAke01hdGgucm91bmQoY29sb3IuZyl9LCAke01hdGgucm91bmQoY29sb3IuYil9LCAke2FscGhhfSlgO1xuICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgICAgIGN0eC5saW5lVG8oeCwgTWF0aC5taW4oeSArIDQsIGhlaWdodCkpO1xuICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8PSBoZWlnaHQ7IHkgKz0gZ3JpZFNpemUpIHtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCArPSA0KSB7XG4gICAgICAgICAgY29uc3QgaW50ZW5zaXR5ID0gZ2V0SW50ZW5zaXR5QXRQb3NpdGlvbih4LCB5LCB0aW1lKTtcbiAgICAgICAgICBpZiAoaW50ZW5zaXR5IDwgMC4xKSBjb250aW51ZTtcblxuICAgICAgICAgIGNvbnN0IGNvbG9yID0gZ2V0Q29sb3JBdFBvc2l0aW9uKHgsIHksIHRpbWUpO1xuICAgICAgICAgIGNvbnN0IGFscGhhID0gaW50ZW5zaXR5ICogMC4xMjtcblxuICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGByZ2JhKCR7TWF0aC5yb3VuZChjb2xvci5yKX0sICR7TWF0aC5yb3VuZChjb2xvci5nKX0sICR7TWF0aC5yb3VuZChjb2xvci5iKX0sICR7YWxwaGF9KWA7XG4gICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgY3R4LmxpbmVUbyhNYXRoLm1pbih4ICsgNCwgd2lkdGgpLCB5KTtcbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYW5pbWF0aW9uSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZHJhdyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlU2Nyb2xsKCkge1xuICAgICAgY29uc3QgZG9jSGVpZ2h0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodCAtIHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGRvY0hlaWdodCkgfHwgZG9jSGVpZ2h0IDw9IDApIHtcbiAgICAgICAgdGFyZ2V0U2Nyb2xsUHJvZ3Jlc3MgPSAwO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0YXJnZXRTY3JvbGxQcm9ncmVzcyA9IHdpbmRvdy5zY3JvbGxZIC8gZG9jSGVpZ2h0O1xuICAgIH1cblxuICAgIHJlc2l6ZSgpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCByZXNpemUpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBoYW5kbGVTY3JvbGwsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICBoYW5kbGVTY3JvbGwoKTtcbiAgICBkcmF3KCk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKGFuaW1hdGlvbklkKSBjYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25JZCk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBoYW5kbGVTY3JvbGwpO1xuICAgIH07XG4gIH0sIFtdKTtcblxuICByZXR1cm4gKFxuICAgIDxjYW52YXNcbiAgICAgIHJlZj17Y2FudmFzUmVmfVxuICAgICAgY2xhc3NOYW1lPXtgcmFpbmJvdy1ncmlkLWNhbnZhcyBmaXhlZCBpbnNldC0wIHotMiBwb2ludGVyLWV2ZW50cy1ub25lIG9wYWNpdHktODAgbWl4LWJsZW5kLXNjcmVlbiAke2NsYXNzTmFtZX1gfVxuICAgIC8+XG4gICk7XG59XG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwiUmFpbmJvd0dyaWQiLCJjbGFzc05hbWUiLCJjYW52YXNSZWYiLCJjdXJyZW50IiwiY2FudmFzIiwiY3R4IiwiZ2V0Q29udGV4dCIsIndpZHRoIiwiaGVpZ2h0Iiwic2Nyb2xsUHJvZ3Jlc3MiLCJ0YXJnZXRTY3JvbGxQcm9ncmVzcyIsImFuaW1hdGlvbklkIiwiZ3JpZFNpemUiLCJjb2xvcnMiLCJyIiwiZyIsImIiLCJyZXNpemUiLCJkcHIiLCJNYXRoIiwibWluIiwid2luZG93IiwiZGV2aWNlUGl4ZWxSYXRpbyIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsInN0eWxlIiwic2V0VHJhbnNmb3JtIiwic2NhbGUiLCJnZXRDb2xvckF0UG9zaXRpb24iLCJ4IiwieSIsInRpbWUiLCJ3YXZlWCIsInNpbiIsIndhdmVZIiwid2F2ZSIsImNvbG9ySW5kZXgiLCJsZW5ndGgiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImNvbG9yQSIsImZsb29yIiwiY29sb3JCIiwiY2VpbCIsInQiLCJnZXRJbnRlbnNpdHlBdFBvc2l0aW9uIiwicHVsc2UxIiwicHVsc2UyIiwicHVsc2UzIiwiY3giLCJjeSIsImRpc3QiLCJzcXJ0IiwibWF4RGlzdCIsInJhZGlhbEZhZGUiLCJwb3ciLCJkcmF3IiwiY2xlYXJSZWN0IiwiaW50ZW5zaXR5IiwiY29sb3IiLCJhbHBoYSIsInN0cm9rZVN0eWxlIiwicm91bmQiLCJsaW5lV2lkdGgiLCJiZWdpblBhdGgiLCJtb3ZlVG8iLCJsaW5lVG8iLCJzdHJva2UiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJoYW5kbGVTY3JvbGwiLCJkb2NIZWlnaHQiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsInNjcm9sbEhlaWdodCIsInNjcm9sbFkiLCJhZGRFdmVudExpc3RlbmVyIiwicGFzc2l2ZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlZiJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/gsap/RainbowGrid.tsx\n"));

/***/ })

});